package apigen

import (
	"fmt"
	"go/format"
	"io"
	"strconv"
	"strings"
	"sync"

	"github.com/morikuni/failure"
)

type Generator struct {
	writer         io.Writer
	b              strings.Builder
	err            error
	errOnce        sync.Once
	services       map[string][]*Method
	definedStructs []*definedStruct
}

func NewGenerator(w io.Writer) *Generator {
	return &Generator{writer: w, services: make(map[string][]*Method)}
}

func (g *Generator) Add(service string, method *Method) {
	g.services[service] = append(g.services[service], method)
}

func (g *Generator) Generate() error {
	g.comment("Code generated by apigen; DO NOT EDIT.")
	g.comment("github.com/ktr0731/apigen")
	g.w("")
	g._package("main")
	g._import("context")

	for name, methods := range g.services {
		g.typeInterface(name, methods)

		for _, m := range methods {
			g.typeStruct(m.Name+"Request", m.req)
			g.typeStruct(m.Name+"Response", m.res)
		}
	}

	out, err := g.gen()
	if err != nil {
		return failure.Wrap(err)
	}

	b, err := format.Source([]byte(out))
	if err != nil {
		return failure.Wrap(err)
	}

	if _, err := g.writer.Write(b); err != nil {
		return failure.Wrap(err)
	}

	return nil
}

func (g *Generator) comment(content string) {
	g.wf("// %s", content)
}

func (g *Generator) _package(name string) {
	g.wf("package %s", name)
}

func (g *Generator) _import(paths ...string) {
	g.w("import (")
	for _, path := range paths {
		g.w(strconv.Quote(path))
	}
	g.w(")")
}

func (g *Generator) typeInterface(name string, methods []*Method) {
	g.wf("type %s interface{", name)
	for _, m := range methods {
		g.wf("%s(ctx context.Context, req *%s) (*%s, error)", m.Name, m.Name+"Request", m.Name+"Response")
	}
	g.w("}")
	g.w("")
}

func (g *Generator) typeStruct(name string, s *_struct) {
	var depStructs []*definedStruct
	g.wf("type %s struct {", name)
	for _, f := range s.fields {
		switch {
		case f._type.isBasic():
			g.wf("%s %s", public(f.name), f._type)
		case f._type == typeStruct:
			v := f.value.(*definedStruct)
			g.wf("%s *%s", public(f.name), v.name) // FieldName is same as f.name.
			depStructs = append(depStructs, v)
		}
	}
	g.w("}")
	g.w("")

	for i := range depStructs {
		g.typeStruct(depStructs[i].name, depStructs[i]._struct)
	}
}

func (g *Generator) structField(name string, s *_struct) {
	g.wf("%s struct {", public(name))
	for _, f := range s.fields {
		switch {
		case f._type.isBasic():
			g.wf("%s %s", public(f.name), f._type)
		case f._type == typeStruct:
			g.structField(f.name, f.value.(*_struct))
		}
	}
	g.w("}")
}

func (g *Generator) w(s string) {
	if g.err != nil {
		return
	}

	_, err := io.WriteString(&g.b, s+"\n")
	g.error(err)
}

func (g *Generator) wf(f string, a ...interface{}) {
	if g.err != nil {
		return
	}

	_, err := fmt.Fprintf(&g.b, f+"\n", a...)
	g.error(err)
}

func (g *Generator) error(err error) {
	if err == nil {
		return
	}
	g.errOnce.Do(func() {
		g.err = err
	})
}

func (g *Generator) gen() (string, error) {
	if g.err != nil {
		return "", g.err
	}
	return g.b.String(), nil
}
